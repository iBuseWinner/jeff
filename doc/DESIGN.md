# cc-jeff

Данный документ излагает дизайн в понятной форме для дальнейшей разработки.

## Что происходит при запуске

Джефф при запуске должен сделать следующие действия:

1. Считать конфигурацию NLPmodule (список баз данных)
2. Подгрузить кэш для NLPmodule
3. Прочитать настройки модулей на Python (**WIP**)

## TBD

1. Добавить в NLPmodule обработку catching-источников
2. Приоритизированные контейнеры добавляют к своим выражениям 30 единиц веса.
3. Если дважды спрашивается одно и то же выражение, сканировать источники вместо выдачи результатов из кэша.
4. Расширить до нормальных размеров все окна-диалоги. +
5. В источниках сделать right-elided текст, чтобы были видны названия баз данных. +
6. Сохранение значений из скриптов. +

## Старый дизайн

Что должна делать ассоциативная система?

1. отвечать на ввод выражений из консоли
2. включать GUI-режим +
3. использовать различные виды баз данных
4. использовать шаблоны +
5. использовать скрипты +
6. сценарии
7. модели
8. шаблоны, скрипты, базы, сценарии, модели, переводы импортируются/экспортируются
9. только вёрстка и создание API
10. поддержка HTML +
11. добавление выражений автоматом +-
12. иметь окна помощи +
13. тратить минимум ресурсов системы +
14. адекватно читать базу из ресурсов +
15. переписать NLPmodule, чтобы не иметь запутанную систему взаимодействий +
16. сделать кэш: +-
    а. в кэш будут сохраняться 50-5000 последних выражений (без повторений), которые были задействованы в ответах +
    б. если выражение не найдено в кэше, то оно ищется в базе данных +
    в. если был задан один и тот же вопрос дважды подряд, то запрос выполняется и в кэше, и в базе данных (вспоминание)
17. избавиться от слов `explicit` в инициализациях классов +

### StandardTemplates
1. inline_templates
    1. `<stdt::currtime"'шаблон времени'">`
    2. `<'название скрипта Python'::'название метода'>` [на самом деле это должно быть в PythonModule]()
    
### Структура данных `Reagent`:
1. активатор
2. ответное выражение
3. список опций и дополнительных параметров
------------------------

Как это работает:
1. вы запускаете программу с ключом --no-gui: вам высвечивается строка ввода '>>>'
2. вы запускаете программу с ключом -a или --answer: вам высвечивается ответ на вопрос в скобочках
3. вы запускаете программу: появляется окно ассоциативной системы

1. сделать помощь
2. сделать скрины +
3. сделать сохранение и вывод виджетов -
4. сделать в настройках пункт выбора приветственного выражения +
11. почему я не использую один query-запрос для всех запросов? Я ведь не распараллеливаю их и не ограничиваю в выполнении одновременно большого числа запросов, поэтому теоретически до тех пор, пока не получено старое значение, новый запрос не должен выполняться +
    Так, это верно, что они выполняются по очереди. Тогда и объект запроса можно сделать один, что ли? Или всё-таки он должен отличаться, от базы к базе? +
12. сделать поддержку тёмных тем на Linux +
13. сделать значки от разных тем на Linux +
Сделать сохранение переписки +
Сделать вывод по 50 сообщений +
Сделать рейз ошибок базы данных +
Сделать хинты в строке ввода при отсутствии оного в течение определённого времени (про добавление выражений, отключение задержки вывода Jeff, добавление баз данных, скрипты, Ctrl+H для отображения менюбара)
Сделать консольный вывод с ограниченными возможностями
Сделать перевод на языки
Сделать перевод строки на ctrl+enter +-
Сделать настройки - время, приветствие, тип сообщений, тема
Есть идея следующего рода: пусть сообщения-виджеты в cn записывают название виджета +
Сделать отключение и удаление контейнеров
Сделать временный файл для сообщений, по частям сообщения грузить +

________________________

Как внедрить Питон:

1. сделать класс, который запускает плагины в отдельных тредах и выдаёт ответ сигналом -
2. сделать пункт в меню, который создаёт сообщение с объяснениями принципов работы и добавлением плагинов

------------------------

`#TODO: подробно описать механизм NLPmodule`  
`#TODO: реализовать необходимые функции NLPmodule`

### PythonModule

1. Функция `provide_actions` (0 аргументов, возвращаемое значение - список кортежей, каждый кортеж состоит из двух строк: краткое название действия и brief).
2. Функция `startup` (0 аргументов, возвращаемое значение - список кортежей, каждый кортеж состоит из двух строк: тип действия и содержимое).
3. Функция `get_events` (0 аргументов, возвращаемое значение - список строк).

Типы действий (для `startup`):
1. `send_to_user`
2. `send_to_nlp`
3. `global_send_from_user`
4. `notify`

Типы событий (для `get_events`):
1. `fast_command`
2. 

Короче, надо придумать, чё будет.
Например, если я хочу добавлять разные действия в редакторе источника, тогда нужны соответствующие шаблоны.
Например, шаблон Википедии:
`Найди в Википедии "{}"` - и здесь, например, шаблон числа/строки внутри

То есть нужно изменить ещё и сам NLPmodule, чтобы тот мог работать с регулярными выражениями)

Спецификация дополнительных полей в источниках:
0 - адрес
1 - выражение
2 - ссылки

3 - флаг передачи введённых данных в скрипт
    Если не NULL, передаём данные в `модуль::функция`
4 - флаг 

1. Попробовать решить проблему с прокруткой тачпадом в ScrollFreezerWidget'ах.
